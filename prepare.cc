// Программа предварительной обработки. Основные задачи этой программы описаны в разделе "Предварительная
// обработка" протокола. Программа принимает три параметра: номер варианта V, путь к каталогу исходной
// коллекции и название файла результата. В каталоге исходной коллекции определяется общее количество
// файлов N (ожидается, что согласно заданию N=12500 или N=50000) и обрабатывает в этом каталоге файлы,
// отсортированные в лексикографическом порядке с индексами согласно варианту. Затем программа
// последовательно обрабатывает каждый файл и записывает в файл результата пары термин-документ.
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <dirent.h>

using namespace std;

// Функция fileNames возвращает отсортированный вектор строк с названием файлов, которые хранятся в
// каталоге коллекции, который задается путем в параметре path.
vector<string> fileNames(const string &path) {
  vector<string> result;
  
  // Открываем каталог
  DIR *dir = opendir(path.c_str());

  // Перебираем записи каталога
  dirent *ent;
  while (ent = readdir(dir)) {
    // Обрабатываем запись.
    if (ent->d_name[0] != '.') { // пропускаем "скрытые" файлы
      if (ent->d_type) { // обрабатываем только регулярные файлы
	// Добавляем имя файла в вектор.
	result.push_back(ent->d_name);
      }
    }
  }

  // Сортируем результат.
  sort(result.begin(), result.end());
  
  return result;
}

// Функция processFile обрабатывает очередной файл. Эта функция выполняет первичную лексическую обработку
// файла. Она читает последовательно символы файла, выделяет слова (термины) и записывает пару
// термин-документ в файл результата.
void processFile(const string &fileName, ofstream &result) {
  // Открываем поток-источник.
  ifstream source(fileName);

  // В буфере term накапливается ключевое слово (термин).
  string term = "";
  
  while (!source.eof()) { // конец файла не достигнут
    // Читаем следующий символ.
    char c;
    source.get(c);

    if (isalpha(c)) { // символ является частью термина
      // Добавляем символ в буфер термина, при этом приводим его к строчному регистру.
      term.push_back(tolower(c));
    } else if (isdigit(c)) { // цифра
      // Цифра не является ни значимым символом ни разделителем, она просто выкидывается.
    } else { // разделительный символ
      // Термин определен, если он не пуст, то 
      if (term.size() > 0) { // термин определен и не пуст
	// Записываем пару термин-документ в файл результата
	result << term << " " << fileName << endl;
	
	// Очищаем буфер термина.
	term = "";
      }
    }
  }
}

int main(int argc, char **argv) {
  // Читаем номер варианта.
  unsigned V = atoi(argv[1]);

  // Читаем путь к каталогу исходной коллекции.
  string colDir = argv[2];

  // Читаем название файла результата
  string resultName = argv[3];

  // Открываем файл результата
  ofstream result(resultName);

  // Получаем лексикографически упорядоченный список имен файлов с содержанием.
  vector<string>fns = fileNames(colDir);

  // Определяем N -- количество файлов в коллекции.
  unsigned N = fns.size();

  // Перебираем только файлы, соответствующие варианту.
  for (unsigned i = N / 50 * (V - 1); i < N / 50 * V; i += 1) {
    // Обрабатываем очередной файл.
    processFile(colDir + "/" + fns[i], result);
  }
  
  return 0;
}
